wget http://libvirt.org/sources/libvirt-0.8.7.tar.gz
tar -zxf libvirt-0.8.7.tar.gz
cd libvirt-0.8.7
patch -p1 < this_patch_file
make clean
./configure --prefix=/usr
make
make install
rmdir /usr/lib/libvirt/drivers/
rmdir /usr/lib/libvirt/
mv -f /usr/lib/libvirt* /lib
ldconfig
---
 configure.ac                       |   38 ++
 src/Makefile.am                    |    8 
 src/security/security_ccsecurity.c |  597 +++++++++++++++++++++++++++++++++++++
 src/security/security_ccsecurity.h |    6 
 src/security/security_driver.c     |    7 
 5 files changed, 656 insertions(+)

--- libvirt-0.8.7.orig/configure.ac
+++ libvirt-0.8.7/configure.ac
@@ -1173,6 +1173,38 @@ fi
 AM_CONDITIONAL([WITH_SECDRIVER_APPARMOR], [test "$with_secdriver_apparmor" != "no"])
 
 
+dnl CCSecurity
+AC_ARG_WITH([ccsecurity],
+  AC_HELP_STRING([--with-ccsecurity], [use CCSecurity to manage security @<:@default=check@:>@]),
+  [],
+  [with_ccsecurity=check])
+
+CCSECURITY_CFLAGS=
+CCSECURITY_LIBS=
+if test "$with_ccsecurity" != "no"; then
+  with_ccsecurity="yes"
+fi
+if test "$with_ccsecurity" = "yes"; then
+  AC_DEFINE_UNQUOTED([HAVE_CCSECURITY], 1, [whether basic CCSecurity functionality is available])
+fi
+AM_CONDITIONAL([HAVE_CCSECURITY], [test "$with_ccsecurity" != "no"])
+AC_SUBST([CCSECURITY_CFLAGS])
+AC_SUBST([CCSECURITY_LIBS])
+
+AC_ARG_WITH([secdriver-ccsecurity],
+  AC_HELP_STRING([--with-secdriver-ccsecurity], [use CCSecurity security driver @<:@default=check@:>@]),
+  [],
+  [with_secdriver_ccsecurity=check])
+
+if test "$with_ccsecurity" = "yes" ; then
+  with_secdriver_ccsecurity=yes
+  AC_DEFINE_UNQUOTED([WITH_SECDRIVER_CCSECURITY], 1, [whether CCSecurity security driver is available])
+else
+  with_secdriver_ccsecurity=no
+fi
+AM_CONDITIONAL([WITH_SECDRIVER_CCSECURITY], [test "$with_secdriver_ccsecurity" != "no"])
+
+
 dnl DTrace static probes
 AC_ARG_WITH([dtrace],
   AC_HELP_STRING([--with-dtrace], [use dtrace for static probing @<:@default=check@:>@]),
@@ -2357,6 +2389,7 @@ AC_MSG_NOTICE([Security Drivers])
 AC_MSG_NOTICE([])
 AC_MSG_NOTICE([ SELinux: $with_secdriver_selinux])
 AC_MSG_NOTICE([AppArmor: $with_secdriver_apparmor])
+AC_MSG_NOTICE([CCSecurity: $with_secdriver_ccsecurity])
 AC_MSG_NOTICE([])
 AC_MSG_NOTICE([Driver Loadable Modules])
 AC_MSG_NOTICE([])
@@ -2419,6 +2452,11 @@ AC_MSG_NOTICE([apparmor: $APPARMOR_CFLAG
 else
 AC_MSG_NOTICE([apparmor: no])
 fi
+if test "$with_ccsecurity" = "yes" ; then
+AC_MSG_NOTICE([ ccsecurity: $CCSECURITY_CFLAGS $CCSECURITY_LIBS])
+else
+AC_MSG_NOTICE([ ccsecurity: no])
+fi
 if test "$with_numactl" = "yes" ; then
 AC_MSG_NOTICE([ numactl: $NUMACTL_CFLAGS $NUMACTL_LIBS])
 else
--- libvirt-0.8.7.orig/src/Makefile.am
+++ libvirt-0.8.7/src/Makefile.am
@@ -398,6 +398,8 @@ SECURITY_DRIVER_SELINUX_SOURCES =				\
 SECURITY_DRIVER_APPARMOR_SOURCES =				\
 		security/security_apparmor.h security/security_apparmor.c
 
+SECURITY_DRIVER_CCSECURITY_SOURCES =				\
+		security/security_ccsecurity.h security/security_ccsecurity.c
 
 NODE_DEVICE_DRIVER_SOURCES =					\
 		node_device/node_device_driver.c \
@@ -960,6 +962,11 @@ libvirt_driver_security_la_SOURCES += $(
 libvirt_driver_security_la_CFLAGS += $(APPARMOR_CFLAGS)
 libvirt_driver_security_la_LIBADD += $(APPARMOR_LIBS)
 endif
+if WITH_SECDRIVER_CCSECURITY
+libvirt_driver_security_la_SOURCES += $(SECURITY_DRIVER_CCSECURITY_SOURCES)
+libvirt_driver_security_la_CFLAGS += $(CCSECURITY_CFLAGS)
+libvirt_driver_security_la_LIBADD += $(CCSECURITY_LIBS)
+endif
 
 # Add all conditional sources just in case...
 EXTRA_DIST +=							\
@@ -991,6 +998,7 @@ EXTRA_DIST +=							\
 		$(NWFILTER_DRIVER_SOURCES)			\
 		$(SECURITY_DRIVER_SELINUX_SOURCES)		\
 		$(SECURITY_DRIVER_APPARMOR_SOURCES)		\
+		$(SECURITY_DRIVER_CCSECURITY_SOURCES)		\
 		$(SECRET_DRIVER_SOURCES)			\
 		$(VBOX_DRIVER_EXTRA_DIST)			\
 		$(VMWARE_DRIVER_SOURCES)
--- /dev/null
+++ libvirt-0.8.7/src/security/security_ccsecurity.c
@@ -0,0 +1,597 @@
+#include <config.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <syslog.h>
+
+#include "security_driver.h"
+#include "security_ccsecurity.h"
+#include "virterror_internal.h"
+#include "util.h"
+#include "memory.h"
+#include "logging.h"
+#include "pci.h"
+#include "hostusb.h"
+#include "storage_file.h"
+#include "uuid.h"
+
+#define VIR_FROM_THIS VIR_FROM_SECURITY
+
+#define SECURITY_CCSECURITY_VOID_DOI       "0"
+#define SECURITY_CCSECURITY_NAME "ccsecurity"
+
+static char *CCSecurityGetUUID(virDomainObjPtr vm)
+{
+	char uuidstr[VIR_UUID_STRING_BUFLEN];
+	char *name;
+	virUUIDFormat(vm->def->uuid, uuidstr);
+	name = strdup(uuidstr);
+	if (!name)
+		virReportOOMError();
+	return name;
+}
+
+static int CCSecurityGenSecurityLabel(virSecurityDriverPtr drv
+				      ATTRIBUTE_UNUSED, virDomainObjPtr vm)
+{
+	if (vm->def->seclabel.type == VIR_DOMAIN_SECLABEL_STATIC)
+		return 0;
+	if (vm->def->seclabel.label || vm->def->seclabel.model ||
+	    vm->def->seclabel.imagelabel) {
+		virSecurityReportError(VIR_ERR_INTERNAL_ERROR, "%s",
+				       "security label already defined for VM"
+				       );
+		return -1;
+	}
+	vm->def->seclabel.label = CCSecurityGetUUID(vm);
+	if (!vm->def->seclabel.label)
+		goto out;
+	vm->def->seclabel.imagelabel = strdup(vm->def->seclabel.label);
+	if (!vm->def->seclabel.imagelabel)
+		goto out;
+	vm->def->seclabel.model = strdup(SECURITY_CCSECURITY_NAME);
+	if (!vm->def->seclabel.model)
+		goto out;
+	return 0;
+out:
+	virSecurityReportError(VIR_ERR_INTERNAL_ERROR,
+			       "cannot generate security context");
+	VIR_FREE(vm->def->seclabel.label);
+	vm->def->seclabel.label = NULL;
+	VIR_FREE(vm->def->seclabel.imagelabel);
+	vm->def->seclabel.imagelabel = NULL;
+	VIR_FREE(vm->def->seclabel.model);
+	vm->def->seclabel.model = NULL;
+ 	return -1;
+}
+
+static int CCSecuritySecurityDriverProbe(void)
+{
+	return close(open("/proc/uuid", O_RDONLY)) == 0 ? SECURITY_DRIVER_ENABLE : SECURITY_DRIVER_DISABLE;
+}
+
+static int CCSecuritySecurityDriverOpen(virSecurityDriverPtr drv,
+					bool allowDiskFormatProbing)
+{
+	/*
+	 * Where will the DOI come from?  CCSecurity configuration, or qemu
+	 * configuration? For the moment, we'll just set it to "0".
+	 */
+	virSecurityDriverSetDOI(drv, SECURITY_CCSECURITY_VOID_DOI);
+	virSecurityDriverSetAllowDiskFormatProbing(drv,
+						   allowDiskFormatProbing);
+	return 0;
+}
+
+static int CCSecurityGetSecurityProcessLabel(virSecurityDriverPtr drv
+					     ATTRIBUTE_UNUSED,
+					     virDomainObjPtr vm
+					     ATTRIBUTE_UNUSED,
+					     virSecurityLabelPtr sec)
+{
+	char uuidstr[VIR_UUID_STRING_BUFLEN];
+	virUUIDFormat(vm->def->uuid, uuidstr);
+	strncpy(sec->label, uuidstr, VIR_SECURITY_LABEL_BUFLEN);
+	sec->label[VIR_SECURITY_LABEL_BUFLEN - 1] = '\0';
+	sec->enforcing = 1;
+	return 0;
+}
+
+static int CCSecuritySetFilecon(const char *path, const virDomainObjPtr vm,
+				const bool is_delete)
+{
+	int ret = -1;
+	char *newpath = NULL;
+	FILE *fp_in = NULL;
+	FILE *fp_out = NULL;
+	char *line = NULL;
+	char buffer[4096];
+	char filename1[128];
+	char filename2[128];
+	const char *uuid;
+	if (!path)
+		return 0;
+	if (virFileResolveLink(path, &newpath) < 0) {
+		VIR_ERROR("cannot resolve symlink %s", path);
+		return -1;
+	}
+	uuid = CCSecurityGetUUID(vm);
+	syslog(LOG_INFO, "%s: %s path=%s uuid=%s name=%s\n", __func__,
+	       is_delete ? "delete" : "add", newpath, uuid, vm->def->name);
+	{
+		const int len = strlen(newpath);
+		char *sp;
+		char *dp;
+		line = malloc(len * 4 + 16);
+		if (!line || len > 65535)
+			goto out;
+		memmove(line, "file open ", 10);
+		dp = line + 10;
+		sp = newpath;
+		while (1) {
+			const unsigned char c = *sp++;
+			if (!c) {
+				*dp++ = '\n';
+				*dp = '\0';
+				break;
+			} else if (c == '\\') {
+				*dp++ = '\\';
+				*dp++ = '\\';
+			} else if (c > ' ' && c < 127) {
+				*dp++ = c;
+			} else {
+				*dp++ = '\\';
+				*dp++ = (c >> 6) + '0';
+				*dp++ = ((c >> 3) & 7) + '0';
+				*dp++ = (c & 7) + '0';
+			}
+		}
+	}
+	memset(filename1, 0, sizeof(filename1));
+	snprintf(filename1, sizeof(filename1) - 1, "/etc/uuid/%s", uuid);
+	fp_in = fopen(filename1, "r");
+	snprintf(filename2, sizeof(filename2) - 1, "/etc/uuid/%s.new", uuid);
+	fp_out = fopen(filename2, "w");
+	if (!is_delete && !fp_in)
+		fp_in = fopen("/dev/null", "r");
+	if (!fp_in || !fp_out)
+		goto out;
+	if (is_delete) {
+		while (memset(buffer, 0, sizeof(buffer)),
+		       fgets(buffer, sizeof(buffer) - 1, fp_in)) {
+			if (strcmp(buffer, line) &&
+			    fprintf(fp_out, "%s", buffer) < 0)
+				goto out;
+		}
+	} else {
+		while (memset(buffer, 0, sizeof(buffer)),
+		       fgets(buffer, sizeof(buffer) - 1, fp_in)) {
+			if (!strcmp(buffer, line))
+				ret = 0;
+			if (fprintf(fp_out, "%s", buffer) < 0)
+				goto out;
+		}
+		if (ret && fprintf(fp_out, "%s", line) < 0)
+			goto out;
+	}
+	if (fflush(fp_out) == 0 && rename(filename2, filename1) == 0)
+		ret = 0;
+out:
+	if (ret)
+		VIR_ERROR("cannot update config file for %s .", uuid);
+	if (fp_in)
+		fclose(fp_in);
+	if (fp_out)
+		fclose(fp_out);
+	free(line);
+	VIR_FREE(newpath);
+	VIR_FREE(uuid);
+	return ret;
+}
+
+static int CCSecurity_RestoreSecurityImageLabel(virDomainObjPtr vm,
+						virDomainDiskDefPtr disk)
+{
+	const virSecurityLabelDefPtr secdef = &vm->def->seclabel;
+	if (secdef->type == VIR_DOMAIN_SECLABEL_STATIC)
+		return 0;
+	return CCSecuritySetFilecon(disk->src, vm, true);
+}
+
+static int CCSecurityRestoreSecurityImageLabel(virSecurityDriverPtr drv
+					       ATTRIBUTE_UNUSED,
+					       virDomainObjPtr vm,
+					       virDomainDiskDefPtr disk)
+{
+	return CCSecurity_RestoreSecurityImageLabel(vm, disk);
+}
+
+static int CCSecuritySetSecurityFileLabel(virDomainDiskDefPtr disk
+					  ATTRIBUTE_UNUSED, const char *path,
+					  size_t depth ATTRIBUTE_UNUSED,
+					  void *opaque)
+{
+	const virDomainObjPtr vm = opaque;
+	return CCSecuritySetFilecon(path, vm, false);
+}
+
+static int CCSecuritySetSecurityImageLabel(virSecurityDriverPtr drv,
+					   virDomainObjPtr vm,
+					   virDomainDiskDefPtr disk)
+{
+	const virSecurityLabelDefPtr secdef = &vm->def->seclabel;
+	bool allowDiskFormatProbing =
+		virSecurityDriverGetAllowDiskFormatProbing(drv);
+	if (secdef->type == VIR_DOMAIN_SECLABEL_STATIC)
+		return 0;
+	return virDomainDiskDefForeachPath(disk, allowDiskFormatProbing, false,
+					   CCSecuritySetSecurityFileLabel,
+					   vm);
+}
+
+static int CCSecuritySetSecurityPCILabel(pciDevice *dev ATTRIBUTE_UNUSED,
+					 const char *file, void *opaque)
+{
+	virDomainObjPtr vm = opaque;
+	return CCSecuritySetFilecon(file, vm, false);
+}
+
+static int CCSecurityRestoreSecurityPCILabel(pciDevice *dev ATTRIBUTE_UNUSED,
+					     const char *file, void *opaque)
+{
+	virDomainObjPtr vm = opaque;
+	return CCSecuritySetFilecon(file, vm, true);
+}
+
+static int CCSecuritySetSecurityUSBLabel(usbDevice *dev ATTRIBUTE_UNUSED,
+					 const char *file, void *opaque)
+{
+	virDomainObjPtr vm = opaque;
+	return CCSecuritySetFilecon(file, vm, false);
+}
+
+static int CCSecurityRestoreSecurityUSBLabel(usbDevice *dev ATTRIBUTE_UNUSED,
+					     const char *file, void *opaque)
+{
+	virDomainObjPtr vm = opaque;
+	return CCSecuritySetFilecon(file, vm, true);
+}
+
+static int CCSecurity_HostdevLabel(virDomainObjPtr vm,
+				   virDomainHostdevDefPtr dev,
+				   const bool is_restore)
+{
+	const virSecurityLabelDefPtr secdef = &vm->def->seclabel;
+	int ret = -1;
+	if (secdef->type == VIR_DOMAIN_SECLABEL_STATIC)
+		return 0;
+	if (dev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)
+		return 0;
+	switch (dev->source.subsys.type) {
+	case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {
+		usbDevice *usb = usbGetDevice(dev->source.subsys.u.usb.bus,
+					      dev->source.subsys.u.usb.device);
+		if (!usb)
+			break;
+		ret = usbDeviceFileIterate(usb, is_restore ?
+					   CCSecurityRestoreSecurityUSBLabel :
+					   CCSecuritySetSecurityUSBLabel,
+					   vm);
+		usbFreeDevice(usb);
+		break;
+	}
+	case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {
+		virDomainDevicePCIAddressPtr p = &dev->source.subsys.u.pci;
+		pciDevice *pci = pciGetDevice(p->domain, p->bus, p->slot,
+					      p->function);
+		if (!pci)
+			break;
+		ret = pciDeviceFileIterate(pci, is_restore ?
+					   CCSecurityRestoreSecurityPCILabel :
+					   CCSecuritySetSecurityPCILabel,
+					   vm);
+		pciFreeDevice(pci);
+		break;
+	}
+	default:
+		ret = 0;
+		break;
+	}
+ 	return ret;
+}
+
+static int CCSecuritySetSecurityHostdevLabel(virSecurityDriverPtr drv
+					     ATTRIBUTE_UNUSED,
+					     virDomainObjPtr vm,
+					     virDomainHostdevDefPtr dev)
+{
+	return CCSecurity_HostdevLabel(vm, dev, false);
+}
+
+static int CCSecurityRestoreSecurityHostdevLabel(virSecurityDriverPtr drv
+						 ATTRIBUTE_UNUSED,
+						 virDomainObjPtr vm,
+						 virDomainHostdevDefPtr dev)
+{
+	return CCSecurity_HostdevLabel(vm, dev, true);
+}
+
+static int CCSecurity_ChardevLabel(virDomainObjPtr vm, virDomainChrDefPtr dev,
+				   const bool is_restore)
+{
+	const virSecurityLabelDefPtr secdef = &vm->def->seclabel;
+	char *in = NULL, *out = NULL;
+	int ret = -1;
+	if (secdef->type == VIR_DOMAIN_SECLABEL_STATIC)
+		return 0;
+	switch (dev->type) {
+	case VIR_DOMAIN_CHR_TYPE_DEV:
+	case VIR_DOMAIN_CHR_TYPE_FILE:
+		ret = CCSecuritySetFilecon(dev->data.file.path, vm,
+					   is_restore);
+		break;
+	case VIR_DOMAIN_CHR_TYPE_PIPE:
+		if ((virAsprintf(&in, "%s.in", dev->data.file.path) < 0) ||
+		    (virAsprintf(&out, "%s.out", dev->data.file.path) < 0)) {
+			virReportOOMError();
+			break;
+		}
+		if (CCSecuritySetFilecon(out, vm, is_restore) < 0 ||
+		    CCSecuritySetFilecon(in, vm, is_restore) < 0)
+			break;
+		ret = 0;
+		break;
+	default:
+		ret = 0;
+		break;
+	}
+	VIR_FREE(in);
+	VIR_FREE(out);
+	return ret;
+}
+
+static int CCSecuritySetSecurityChardevLabel(virDomainObjPtr vm,
+					     virDomainChrDefPtr dev)
+{
+	return CCSecurity_ChardevLabel(vm, dev, false);
+}
+
+static int CCSecurityRestoreSecurityChardevLabel(virDomainObjPtr vm,
+						 virDomainChrDefPtr dev)
+{
+	return CCSecurity_ChardevLabel(vm, dev, true);
+}
+
+static int CCSecurityRestoreSecurityChardevCallback(virDomainDefPtr def
+						    ATTRIBUTE_UNUSED,
+						    virDomainChrDefPtr dev,
+						    void *opaque)
+{
+	virDomainObjPtr vm = opaque;
+	return CCSecurityRestoreSecurityChardevLabel(vm, dev);
+}
+
+static int CCSecurityReleaseSecurityLabel(virSecurityDriverPtr drv
+					  ATTRIBUTE_UNUSED, virDomainObjPtr vm)
+{
+	const virSecurityLabelDefPtr secdef = &vm->def->seclabel;
+	//if (secdef->type == VIR_DOMAIN_SECLABEL_STATIC)
+	//	return 0;
+	VIR_FREE(secdef->model);
+	secdef->model = NULL;
+	VIR_FREE(secdef->label);
+	secdef->label = NULL;
+	VIR_FREE(secdef->imagelabel);
+	secdef->imagelabel = NULL;
+	return 0;
+}
+
+static int CCSecuritySetSavedStateLabel(virSecurityDriverPtr drv
+					ATTRIBUTE_UNUSED, virDomainObjPtr vm,
+					const char *savefile)
+{
+	const virSecurityLabelDefPtr secdef = &vm->def->seclabel;
+	if (secdef->type == VIR_DOMAIN_SECLABEL_STATIC)
+		return 0;
+	return CCSecuritySetFilecon(savefile, vm, false);
+}
+
+static int CCSecurityRestoreSavedStateLabel(virSecurityDriverPtr drv
+					    ATTRIBUTE_UNUSED,
+					    virDomainObjPtr vm,
+					    const char *savefile)
+{
+	const virSecurityLabelDefPtr secdef = &vm->def->seclabel;
+	if (secdef->type == VIR_DOMAIN_SECLABEL_STATIC)
+		return 0;
+	return CCSecuritySetFilecon(savefile, vm, true);
+}
+
+static int CCSecuritySecurityVerify(virDomainDefPtr def)
+{
+	const virSecurityLabelDefPtr secdef = &def->seclabel;
+	if (secdef->type == VIR_DOMAIN_SECLABEL_STATIC)
+		syslog(LOG_INFO, "%s:VM=%s secdef->label=%s\n", __func__,
+		       def->name, secdef->label);
+	return 0;
+}
+
+static int CCSecuritySetSecurityProcessLabel(virSecurityDriverPtr drv,
+					     virDomainObjPtr vm)
+{
+	/* TODO: verify DOI */
+	const virSecurityLabelDefPtr secdef = &vm->def->seclabel;
+	if (secdef->label == NULL)
+		return 0;
+	if (STREQ(drv->name, secdef->model)) {
+		/* TODO: Write to /proc/ccs/self_domain now? */
+		int fd = open("/proc/uuid", O_WRONLY);
+		int err;
+		if (write(fd, vm->def->uuid, sizeof(vm->def->uuid)) == sizeof(vm->def->uuid)) {
+			close(fd);
+			syslog(LOG_INFO, "%s:VM=%s secdef->label=%s\n", __func__,
+			       vm->def->name, secdef->label);
+			return 0;
+		}
+		err = errno;
+		close(fd);
+		virSecurityReportError(VIR_ERR_INTERNAL_ERROR,
+				       _("Can't allocate security label. %u"), err);
+		return -1;
+	}
+	virSecurityReportError(VIR_ERR_INTERNAL_ERROR,
+			       _("security label driver mismatch: "
+				 "'%s' model configured for domain, but "
+				 "hypervisor driver is '%s'."),
+			       secdef->model, drv->name);
+	return -1;
+}
+
+static int CCSecuritySetSecurityChardevCallback(virDomainDefPtr def
+						ATTRIBUTE_UNUSED,
+						virDomainChrDefPtr dev,
+						void *opaque)
+{
+	virDomainObjPtr vm = opaque;
+	return CCSecuritySetSecurityChardevLabel(vm, dev);
+}
+
+static int CCSecurity_SecurityAllLabel(virSecurityDriverPtr drv,
+				       virDomainObjPtr vm,
+				       const char *stdin_path,
+				       const bool is_restore)
+{
+	const virDomainDefPtr def = vm->def;
+	const virSecurityLabelDefPtr secdef = &def->seclabel;
+	int i;
+	int rc = 0;
+	if (secdef->type == VIR_DOMAIN_SECLABEL_STATIC)
+		return 0;
+	for (i = 0; i < def->ndisks; i++)
+		if (is_restore) {
+			if (CCSecurity_RestoreSecurityImageLabel(vm,
+								 def->disks[i])
+			    < 0)
+				rc = -1;
+		} else {
+			if (CCSecuritySetSecurityImageLabel(drv, vm,
+							    def->disks[i]) < 0)
+				rc = -1;
+		}
+	for (i = 0; i < def->nhostdevs; i++)
+		if (is_restore) {
+			if (CCSecurityRestoreSecurityHostdevLabel(drv, vm,
+								  def->hostdevs[i]) < 0)
+				rc = -1;
+		} else {
+			if (CCSecuritySetSecurityHostdevLabel(drv, vm,
+							      def->hostdevs[i])
+			    < 0)
+				rc = -1;
+		}
+	if (virDomainChrDefForeach(def, !is_restore,
+				   is_restore ?
+				   CCSecurityRestoreSecurityChardevCallback :
+				   CCSecuritySetSecurityChardevCallback,
+				   vm) < 0)
+		rc = -1;
+	if (CCSecuritySetFilecon(def->os.kernel, vm, is_restore) < 0)
+		rc = -1;
+	if (CCSecuritySetFilecon(def->os.initrd, vm, is_restore) < 0)
+		rc = -1;
+	if (CCSecuritySetFilecon(stdin_path, vm, is_restore) < 0)
+		rc = -1;
+	return rc;
+}
+
+static int CCSecuritySetSecurityAllLabel(virSecurityDriverPtr drv,
+					 virDomainObjPtr vm,
+					 const char *stdin_path)
+{
+	return CCSecurity_SecurityAllLabel(drv, vm, stdin_path, false);
+}
+
+static int CCSecurityRestoreSecurityAllLabel(virSecurityDriverPtr drv,
+					     virDomainObjPtr vm,
+					     int migrated ATTRIBUTE_UNUSED)
+{
+	return CCSecurity_SecurityAllLabel(drv, vm, NULL, true);
+}
+
+virSecurityDriver virCCSecuritySecurityDriver = {
+	.name                              = SECURITY_CCSECURITY_NAME,
+	.probe                             = CCSecuritySecurityDriverProbe,
+	.open                              = CCSecuritySecurityDriverOpen,
+	.domainSecurityVerify              = CCSecuritySecurityVerify,
+	.domainSetSecurityImageLabel       = CCSecuritySetSecurityImageLabel,
+	/*
+	.domainSetSecuritySocketLabel      = CCSecuritySetSecuritySocketLabel,
+	.domainClearSecuritySocketLabel    =
+	CCSecurityClearSecuritySocketLabel,
+	*/
+	.domainRestoreSecurityImageLabel   =
+	CCSecurityRestoreSecurityImageLabel,
+	.domainGenSecurityLabel            = CCSecurityGenSecurityLabel,
+	/*
+	.domainReserveSecurityLabel        = CCSecurityReserveSecurityLabel,
+	*/
+	.domainReleaseSecurityLabel        = CCSecurityReleaseSecurityLabel,
+	.domainGetSecurityProcessLabel     = CCSecurityGetSecurityProcessLabel,
+	.domainSetSecurityProcessLabel     = CCSecuritySetSecurityProcessLabel,
+	.domainRestoreSecurityAllLabel     = CCSecurityRestoreSecurityAllLabel,
+	.domainSetSecurityAllLabel         = CCSecuritySetSecurityAllLabel,
+	.domainSetSecurityHostdevLabel     = CCSecuritySetSecurityHostdevLabel,
+	.domainRestoreSecurityHostdevLabel =
+	CCSecurityRestoreSecurityHostdevLabel,
+	.domainSetSavedStateLabel          = CCSecuritySetSavedStateLabel,
+	.domainRestoreSavedStateLabel      = CCSecurityRestoreSavedStateLabel,
+};
+
+#if 0
+static int CCSecuritySetSecuritySocketLabel(virSecurityDriverPtr drv,
+					    virDomainObjPtr vm)
+{
+	/* TODO: verify DOI */
+	const virSecurityLabelDefPtr secdef = &vm->def->seclabel;
+	if (secdef->label == NULL)
+		return 0;
+	if (STREQ(drv->name, secdef->model)) {
+		syslog(LOG_INFO, "%s:VM=%s secdef->label=%s\n", __func__,
+		       vm->def->name, secdef->label);
+		return 0;
+	}
+ 	virSecurityReportError(VIR_ERR_INTERNAL_ERROR,
+			       _("security label driver mismatch: "
+				 "'%s' model configured for domain, but "
+				 "hypervisor driver is '%s'."),
+			       secdef->model, drv->name);
+	return -1;
+}
+
+static int CCSecurityClearSecuritySocketLabel(virSecurityDriverPtr drv,
+					      virDomainObjPtr vm)
+{
+	/* TODO: verify DOI */
+	const virSecurityLabelDefPtr secdef = &vm->def->seclabel;
+	if (secdef->label == NULL)
+		return 0;
+	if (STREQ(drv->name, secdef->model)) {
+		syslog(LOG_INFO, "%s\n", __func__);
+		return 0;
+	}
+	virSecurityReportError(VIR_ERR_INTERNAL_ERROR,
+			       _("security label driver mismatch: "
+				 "'%s' model configured for domain, but "
+				 "hypervisor driver is '%s'."),
+			       secdef->model, drv->name);
+	return -1;
+}
+
+static int CCSecurityReserveSecurityLabel(virSecurityDriverPtr drv
+					  ATTRIBUTE_UNUSED,
+					  virDomainObjPtr vm ATTRIBUTE_UNUSED)
+{
+	return 0;
+}
+
+#endif
--- /dev/null
+++ libvirt-0.8.7/src/security/security_ccsecurity.h
@@ -0,0 +1,6 @@
+#ifndef __VIR_SECURITY_CCSECURITY_H__
+# define __VIR_SECURITY_CCSECURITY_H__
+
+extern virSecurityDriver virCCSecuritySecurityDriver;
+
+#endif
--- libvirt-0.8.7.orig/src/security/security_driver.c
+++ libvirt-0.8.7/src/security/security_driver.c
@@ -24,6 +24,10 @@
 # include "security_apparmor.h"
 #endif
 
+#ifdef WITH_SECDRIVER_CCSECURITY
+# include "security_ccsecurity.h"
+#endif
+
 static virSecurityDriverPtr security_drivers[] = {
 #ifdef WITH_SECDRIVER_SELINUX
     &virSELinuxSecurityDriver,
@@ -31,6 +35,9 @@ static virSecurityDriverPtr security_dri
 #ifdef WITH_SECDRIVER_APPARMOR
     &virAppArmorSecurityDriver,
 #endif
+#ifdef WITH_SECDRIVER_CCSECURITY
+    &virCCSecuritySecurityDriver,
+#endif
     NULL
 };
 
